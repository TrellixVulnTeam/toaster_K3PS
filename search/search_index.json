{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Toaster A simple package manager for macOS/Linux with support for binary packages and app bundles!","title":"Toaster"},{"location":"#toaster","text":"A simple package manager for macOS/Linux with support for binary packages and app bundles!","title":"Toaster"},{"location":"Contributors/roadmap/","text":"Roadmap A list of things to do (for contributors) Properly implement OS and architecture specific instructions Properly implement uninstall scripts Properly implement sources (\"bakery\"), bakery configuration files, and bakery updates (actually get bakeries from git, store them, handle updates for them, and use them when installing/removing/updating packages) Implement custom bakery support (part of above) Actually install packages to correct directories Better packages support (custom links) Lock database Clean-up install package function Properly implement package updates Support binaries Implement hash checking Safer package updates Allow caching packages Clean up any bad code/comments See Making installer ** MILESTONE #1: Support \"apps\" Once you're here, your hard work has paid off, so clean up any code and add more packages duh :) See Making installer once again Document toaster and document how bakeries work MILESTONE #2: Make toaster and toaster-core public MILESTONE #3: Launch toaster alpha for macOS Support custom installation paths Test and make any needed fixes for Linux idk whether to put a :) or :( See Making installer once again MILESTONE #4: Launch toaster alpha for Linux Fix any bugs that arise Add new features MILESTONE #5: Launch toaster beta for macOS and Linux Making installer Automatically find Python 3 and install required Python dependencies Move toaster itself to somewhere and add that to path Make /opt/toaster dirs and initiate git stuff there Add toaster's binary directories to path","title":"Roadmap"},{"location":"Contributors/roadmap/#roadmap","text":"A list of things to do (for contributors) Properly implement OS and architecture specific instructions Properly implement uninstall scripts Properly implement sources (\"bakery\"), bakery configuration files, and bakery updates (actually get bakeries from git, store them, handle updates for them, and use them when installing/removing/updating packages) Implement custom bakery support (part of above) Actually install packages to correct directories Better packages support (custom links) Lock database Clean-up install package function Properly implement package updates Support binaries Implement hash checking Safer package updates Allow caching packages Clean up any bad code/comments See Making installer ** MILESTONE #1: Support \"apps\" Once you're here, your hard work has paid off, so clean up any code and add more packages duh :) See Making installer once again Document toaster and document how bakeries work MILESTONE #2: Make toaster and toaster-core public MILESTONE #3: Launch toaster alpha for macOS Support custom installation paths Test and make any needed fixes for Linux idk whether to put a :) or :( See Making installer once again MILESTONE #4: Launch toaster alpha for Linux Fix any bugs that arise Add new features MILESTONE #5: Launch toaster beta for macOS and Linux","title":"Roadmap"},{"location":"Contributors/roadmap/#making-installer","text":"Automatically find Python 3 and install required Python dependencies Move toaster itself to somewhere and add that to path Make /opt/toaster dirs and initiate git stuff there Add toaster's binary directories to path","title":"Making installer"},{"location":"Package%20Maintainers/makingapackage/","text":"Making a Package So, there's an application you want to add to toaster? or maybe you're just curious? Well, either way, keep reading to know all you need to know about how toaster packages work. Package files Every package has a TOML file named after the package, which describes how the package should be installed and uninstalled. Here is an example of how a bakery (a git repo with packages in it) may be structured: wxllow/toaster-core \u251c\u2500\u2500 _toaster.toml \u251c\u2500\u2500 coolexample \u2502 \u2514\u2500\u2500 coolexample.toml \u251c\u2500\u2500 example \u2514\u2500\u2500 example.toml Basic information First in a package's TOML file is information like the name, version, license, dependencies, and which architectures/platforms it supports. Here is an example of how this may look: name = 'example' desc = 'An example package.' version = '1.0.0' version_type = 'development' license = \"MIT\" archs = ['universal'] # Possible values: 'arm64', 'x86_64', 'universal' linux_archs = ['any'] # Possible values: 'any', 'x86_64' types = ['binary', 'build'] # Possible values: 'binary', 'build', 'app' dependencies = ['python>3.8', 'go'] Name and Description The first 2 things here are the name and description, which are pretty self-explanatory. Version Next is the version and the version type. These can be any string, but we recommend using a semantic version number and having version_type either be stable , development , prototype , beta , alpha , or something along those lines License The license is pretty self-explanatory and can also be anything, but make sure that users are able to understand what the license means Archs (macOS) Here you can specify which architectures you wish to target on macOS, either universal , arm64 , or x86_64 Archs (Linux) Here, you can specify which architectures you wish to target on Linux... either any or x86_64 Types This is where you specify which type(s) your package supports. This can be build , binary , or app build means an application that is built from source code binary means a pre-built binary package app means a GUI-only .app bundle (macOS only) Dependencies Here is where you can place all the other packages you require to be installed to install your package. You can specify just a package's name, like go , or a minimum version to be required for the package, like python>=3.7 . Build Here is an example [build] repo = 'https://github.com/foo/bar' branch = 'master' format_scripts = true scripts = [['./configure', '--prefix {prefix}'], [['make'], ['install']]] # Indentation is optional btw :) [[build.universal]] scripts = [['echo', 'hello, apple!']] post_scripts = [['echo', 'hello again, apple!']] [[build.uninstall]] [[build.uninstall.universal]] scripts = [['echo', 'bye bye, apple!']] Repository The first two items here tell toaster which Git repo to download the source code from and which branch of that repo to use. Format Scripts? This is a boolean which tells toaster whether it should format scripts with things like {prefix} which contain data, such as where the package should be installed, in the case of {prefix}. Link dirs List of directorys that you wish to be linked to PATH after installation. Paths are relative to the package directory ({prefix}). Defaults to ['bin'] Scripts These are scripts to run during installation in the temp directory with the package's source code . This could be things like ./configure --prefix {prefix} This should be a list containing commands to run. Commands should also be a list, seperated by their arguments. For example, [['./configure', '--prefix {prefix}'], ['make', 'install']] . This is for security reasons. If you have experience with for example the subprocess library on Python, you are likely already be familiar with this. Post-scripts These are scripts that are run right before installation is finished and are ran in the project directory. These work the same as regular scripts, just ran at a different time and in a different directory. Platform-Specific Instructions Platform/architecture specific instructions can be used. These will either overwrite their general values or append them (if the item is a list) For example: [[build.universal]] scripts = [['echo', 'hello, apple!']] post_scripts = [['echo', 'hello again, apple!']] [[build.linux_any]] scripts = [['echo', 'hello, tux!']] post_scripts = [['echo', 'hello again, tux!']","title":"Making a Package"},{"location":"Package%20Maintainers/makingapackage/#making-a-package","text":"So, there's an application you want to add to toaster? or maybe you're just curious? Well, either way, keep reading to know all you need to know about how toaster packages work.","title":"Making a Package"},{"location":"Package%20Maintainers/makingapackage/#package-files","text":"Every package has a TOML file named after the package, which describes how the package should be installed and uninstalled. Here is an example of how a bakery (a git repo with packages in it) may be structured: wxllow/toaster-core \u251c\u2500\u2500 _toaster.toml \u251c\u2500\u2500 coolexample \u2502 \u2514\u2500\u2500 coolexample.toml \u251c\u2500\u2500 example \u2514\u2500\u2500 example.toml","title":"Package files"},{"location":"Package%20Maintainers/makingapackage/#basic-information","text":"First in a package's TOML file is information like the name, version, license, dependencies, and which architectures/platforms it supports. Here is an example of how this may look: name = 'example' desc = 'An example package.' version = '1.0.0' version_type = 'development' license = \"MIT\" archs = ['universal'] # Possible values: 'arm64', 'x86_64', 'universal' linux_archs = ['any'] # Possible values: 'any', 'x86_64' types = ['binary', 'build'] # Possible values: 'binary', 'build', 'app' dependencies = ['python>3.8', 'go']","title":"Basic information"},{"location":"Package%20Maintainers/makingapackage/#name-and-description","text":"The first 2 things here are the name and description, which are pretty self-explanatory.","title":"Name and Description"},{"location":"Package%20Maintainers/makingapackage/#version","text":"Next is the version and the version type. These can be any string, but we recommend using a semantic version number and having version_type either be stable , development , prototype , beta , alpha , or something along those lines","title":"Version"},{"location":"Package%20Maintainers/makingapackage/#license","text":"The license is pretty self-explanatory and can also be anything, but make sure that users are able to understand what the license means","title":"License"},{"location":"Package%20Maintainers/makingapackage/#archs-macos","text":"Here you can specify which architectures you wish to target on macOS, either universal , arm64 , or x86_64","title":"Archs (macOS)"},{"location":"Package%20Maintainers/makingapackage/#archs-linux","text":"Here, you can specify which architectures you wish to target on Linux... either any or x86_64","title":"Archs (Linux)"},{"location":"Package%20Maintainers/makingapackage/#types","text":"This is where you specify which type(s) your package supports. This can be build , binary , or app build means an application that is built from source code binary means a pre-built binary package app means a GUI-only .app bundle (macOS only)","title":"Types"},{"location":"Package%20Maintainers/makingapackage/#dependencies","text":"Here is where you can place all the other packages you require to be installed to install your package. You can specify just a package's name, like go , or a minimum version to be required for the package, like python>=3.7 .","title":"Dependencies"},{"location":"Package%20Maintainers/makingapackage/#build","text":"Here is an example [build] repo = 'https://github.com/foo/bar' branch = 'master' format_scripts = true scripts = [['./configure', '--prefix {prefix}'], [['make'], ['install']]] # Indentation is optional btw :) [[build.universal]] scripts = [['echo', 'hello, apple!']] post_scripts = [['echo', 'hello again, apple!']] [[build.uninstall]] [[build.uninstall.universal]] scripts = [['echo', 'bye bye, apple!']]","title":"Build"},{"location":"Package%20Maintainers/makingapackage/#repository","text":"The first two items here tell toaster which Git repo to download the source code from and which branch of that repo to use.","title":"Repository"},{"location":"Package%20Maintainers/makingapackage/#format-scripts","text":"This is a boolean which tells toaster whether it should format scripts with things like {prefix} which contain data, such as where the package should be installed, in the case of {prefix}.","title":"Format Scripts?"},{"location":"Package%20Maintainers/makingapackage/#link-dirs","text":"List of directorys that you wish to be linked to PATH after installation. Paths are relative to the package directory ({prefix}). Defaults to ['bin']","title":"Link dirs"},{"location":"Package%20Maintainers/makingapackage/#scripts","text":"These are scripts to run during installation in the temp directory with the package's source code . This could be things like ./configure --prefix {prefix} This should be a list containing commands to run. Commands should also be a list, seperated by their arguments. For example, [['./configure', '--prefix {prefix}'], ['make', 'install']] . This is for security reasons. If you have experience with for example the subprocess library on Python, you are likely already be familiar with this.","title":"Scripts"},{"location":"Package%20Maintainers/makingapackage/#post-scripts","text":"These are scripts that are run right before installation is finished and are ran in the project directory. These work the same as regular scripts, just ran at a different time and in a different directory.","title":"Post-scripts"},{"location":"Package%20Maintainers/makingapackage/#platform-specific-instructions","text":"Platform/architecture specific instructions can be used. These will either overwrite their general values or append them (if the item is a list) For example: [[build.universal]] scripts = [['echo', 'hello, apple!']] post_scripts = [['echo', 'hello again, apple!']] [[build.linux_any]] scripts = [['echo', 'hello, tux!']] post_scripts = [['echo', 'hello again, tux!']","title":"Platform-Specific Instructions"},{"location":"Users/gettingstarted/","text":"Getting Started To be written","title":"Getting Started"},{"location":"Users/gettingstarted/#getting-started","text":"To be written","title":"Getting Started"}]}